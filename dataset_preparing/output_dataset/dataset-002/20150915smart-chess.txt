студент имперского колледжа лондоне создал шахматную компьютерную программу giraff которая полностью построена принципах машинного обучения использует вручную настроенные инструменты анализа партии giraff обучалась ходе игры самим собой рекордные 72 часа достигла уровня соответствующего двум верхним процентам рейтинга версии международной шахматной ассоциации препринт магистерской диссертации описанием программы выложен arxivorgавтор использовал два подхода принципиально отличавших giraff аналогичных шахматных программ вопервых оценки позиции доске алгоритм автоматически отбирал наиболее значимые признаки ходе игр самим собой пример машинного обучения подкреплением этом программа имела доступа предварительно заложенным рекомендациям известным например привлечения шахматных экспертов разработке предварительного анализа большого числа партийвовторых giraff использовался качественно новый подход анализу дерева решений ходе типичной шахматной партии возникнуть огромное число допустимых вариантов хода проанализировать необходимы вычислительные мощности доступные только суперкомпьютерах снизить объем вычислений алгоритм каждом ходе анализирует лишь часть дерева решенийтрадиционно шахматных программах применяется метод основанный максимальной длине ветвей например каждом ходе алгоритм проанализирует доступные ветви далее чем 10 ходов giraff автор вместо длины ветви использовал значение вероятности данная ветвь приведет наиболее длинной цепочке ходов таким образом анализировались только ветви которых эта вероятность выше определенного порогаза таким методом существует следующее объяснение поиск наилучшего хода основан предположении противник выберет наилучший ход таким образом партия будет развиваться настолько долго насколько возможно этом некоторые ситуации доске примеру шах размен ценных фигур требуют обязательных ответных ходов таким образом ограничивая число возможных продолжений например данной партии происходит размен ферзей алгоритм основанный глубине ветви будет анализировать числе доступные ветви где ферзя всетаки взяли просто потому ветви окажутся короче пороговой величины этом алгоритм основе вероятностей наоборот будет двигаться сторону наиболее длинной ветви наименьшим числом развилок